\section{Общие сведения о программе}

Код курсового проекта состоит из трех файлов: A.c, B.c и C.c, названия соответствуют программам из условия. При запуске программы A создаются 4 пайпа для связи между всеми программами, затем просходит два форка для создания дочерних программ (B и C). После форка в каждой программе закрываются ненужные стороны пайпов, образы дочерних программ заменяются на соответствующие программы с помощью $execl()$. Программы $B$ и $C$ используют $prctl()$ для того, чтобы они завершались в случае неожиданной смерти родителя. Далее основная программа $A$ принимает ввод по строкам, отправляет длину ввода в $B$, а само сообщение в $C$. $C$ отправляет длину принятого сообщения в $B$, выводит принятое сообщение и уведомляет программу $A$ об успехе. Программа $B$, приняв длину от программ $A$ и $C$ сразу же выводит её.

\pagebreak

\section{Общий метод и алгоритм решения}

Для реализации поставленной задачи необходимо:

\begin{enumerate}
    \item Вспомнить принцип работы fork, pipe, prctl, execl
    \item Написать код для создания программ $B$ и $C$ в программе $A$
    \item Написать основной цикл программы $A$
    \item Написать программу $C$
    \item Написать программу $B$
    \item Написать обработку ошибок
\end{enumerate}

\pagebreak

\section{Исходный код}

\textbf{A.c}

\begin{lstlisting}[language=C]

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>

#include <unistd.h>

#define BUFF_SIZE 256

#define READ 0
#define WRITE 1
#define MAX_ARG_LEN 8


int main() {
    int fd_A2C[2];
    int fd_A2B[2];
    int fd_C2A[2];
    int fd_C2B[2];

    if (pipe(fd_A2C) || pipe(fd_A2B) || pipe(fd_C2A) || pipe(fd_C2B)) {
        perror("Error");
        exit(EXIT_FAILURE);
    }

    pid_t parent_pid = getpid();

    pid_t proc_C_pid = fork();
    if (proc_C_pid == -1) {
        perror("Error");
        exit(EXIT_FAILURE);
    }
    else if (proc_C_pid == 0) {
        close(fd_A2B[READ]);
        close(fd_A2B[WRITE]);
        close(fd_A2C[WRITE]);
        close(fd_C2B[READ]);
        close(fd_C2A[READ]);

        char ppid[MAX_ARG_LEN + 1];
        snprintf(ppid, MAX_ARG_LEN + 1, "%d", parent_pid);

        char read_A[MAX_ARG_LEN + 1];
        snprintf(read_A, MAX_ARG_LEN + 1, "%d", fd_A2C[READ]);

        char write_B[MAX_ARG_LEN + 1];
        snprintf(write_B, MAX_ARG_LEN + 1, "%d", fd_C2B[WRITE]);

        char write_A[MAX_ARG_LEN + 1];
        snprintf(write_A, MAX_ARG_LEN + 1, "%d", fd_C2A[WRITE]);

        execl("./C", ppid, read_A, write_B, write_A, (char *) NULL);
        kill(parent_pid, SIGABRT);
    }

    pid_t proc_B_pid = fork();
    if (proc_B_pid == -1) {
        perror("Error");
        kill(proc_C_pid, SIGABRT);
        exit(EXIT_FAILURE);
    }
    else if (proc_B_pid == 0) {
        close(fd_A2C[READ]);
        close(fd_A2C[WRITE]);
        close(fd_C2A[READ]);
        close(fd_C2A[WRITE]);
        close(fd_A2B[WRITE]);
        close(fd_C2B[WRITE]);

        char ppid[MAX_ARG_LEN + 1];
        snprintf(ppid, MAX_ARG_LEN + 1, "%d", parent_pid);

        char read_A[MAX_ARG_LEN + 1];
        snprintf(read_A, MAX_ARG_LEN + 1, "%d", fd_A2B[READ]);

        char read_C[MAX_ARG_LEN + 1];
        snprintf(read_C, MAX_ARG_LEN + 1, "%d", fd_C2B[READ]);

        execl("./B", ppid, read_A, read_C, (char *) NULL);
        kill(parent_pid, SIGABRT);
    }

    close(fd_C2B[READ]);
    close(fd_C2B[WRITE]);
    close(fd_C2A[WRITE]);
    close(fd_A2C[READ]);
    close(fd_A2B[READ]);
    
    char buff[BUFF_SIZE + 1];
    while (fgets(buff, BUFF_SIZE + 1, stdin) != NULL) {
        size_t input_len = strlen(buff) - 1;
        printf("A sent string: %s", buff);
        write(fd_A2B[WRITE], &input_len, sizeof(size_t));
        write(fd_A2C[WRITE], buff, BUFF_SIZE + 1);
        int temp;
        read(fd_C2A[READ], &temp, sizeof(int));
    }

    kill(proc_C_pid, SIGTERM);
    kill(proc_B_pid, SIGTERM);

    close(fd_A2C[WRITE]);
    close(fd_A2B[WRITE]);
    close(fd_C2A[READ]);

    return 0;
}

\end{lstlisting}

\textbf{C.c}

\begin{lstlisting}[language=C]

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>

#include <unistd.h>
#include <sys/prctl.h>

#define BUFF_SIZE 256

int read_A;
int write_B;
int write_A;

void parent_death(int sig) {
    exit(EXIT_FAILURE);
}

void parent_end(int sig) {
    close(read_A);
    close(write_B);
    close(write_A);
    exit(EXIT_SUCCESS);
}

int main(int argc, char **argv) {
    pid_t parent_pid = atoi(argv[0]);
    prctl(PR_SET_PDEATHSIG, SIGABRT);
    signal(SIGABRT, parent_death);
    if (getppid() != parent_pid) {
        parent_death(SIGABRT);
    }
    signal(SIGTERM, parent_end);

    read_A = atoi(argv[2]);
    write_B = atoi(argv[3]);
    write_A = atoi(argv[4]);

    char buff[BUFF_SIZE + 1];
    while (1) {
        read(read_A, buff, BUFF_SIZE + 1);
        printf("C got string: %s", buff);
        size_t input_len = strlen(buff) - 1;
        write(write_B, &input_len, sizeof(size_t));
        int temp = 1;
        write(write_A, &temp, sizeof(int));  
    }

    return 0;
}

\end{lstlisting}

\textbf{B.c}

\begin{lstlisting}[language=C]

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>

#include <unistd.h>
#include <sys/prctl.h>

#define BUFF_SIZE 256

int read_A;
int read_C;

void parent_death(int sig) {
    exit(EXIT_FAILURE);
}

void parent_end(int sig) {
    close(read_A);
    close(read_C);
    exit(EXIT_SUCCESS);
}

int main(int argc, char **argv) {
    pid_t parent_pid = atoi(argv[0]);
    prctl(PR_SET_PDEATHSIG, SIGABRT);
    signal(SIGABRT, parent_death);
    if (getppid() != parent_pid) {
        parent_death(SIGABRT);
    }
    signal(SIGTERM, parent_end);

    read_A = atoi(argv[2]);
    read_C = atoi(argv[3]);

    size_t from_A;
    size_t from_C;
    while (1) {
        read(read_A, &from_A, sizeof(size_t));
        printf("B got length %zu from A\n", from_A);
        read(read_C, &from_C, sizeof(size_t));
        printf("B got length %zu from C\n", from_C);
    }

    return 0;
}

\end{lstlisting}

\pagebreak