<HTML>
<HEAD>
<TITLE>Понимание SQL. Глава 19. Поддержка целостности ваших данных. [SQL.RU]</TITLE>
<META http-equiv="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Window-target" CONTENT="_top">
<META HTTP-EQUIV="Last-Modified" CONTENT="29-03-2001">
<META NAME="Description" CONTENT="Использование языка SQL, создание клиент-серверных систем. Конференция по MSSQL, Oracle, Interbase, MySQL. Полезные ссылки, документация, рекомендации по разработке информационных систем, сертификация, заказ книг и многое другое.">
<META NAME="Keywords" CONTENT="SQL, конференция, Database Server, Oracle, Interbase, MySQL, документация, статьи, примеры, книги, ссылки, сертификация, работа, СУБД">
<LINK REL=STYLESHEET TYPE="text/css" HREF="../../../form.css" tppabs="http://www.sql.ru/form.css">
</HEAD>
<BODY BGCOLOR="#FFFFFF" leftmargin="3" topmargin="3" marginheight="3" marginwidth="3">
<noindex>
<TABLE BGCOLOR="#000000" WIDTH=100% CELLPADDING=0 CELLSPACING=0 BORDER=0>
<TR><TD>

<TABLE WIDTH=100% CELLPADDING=0 CELLSPACING=1 BORDER=0>
<TR BGCOLOR="#6699CC"><TD><TABLE CELLSPACING=0 CELLPADDING=0 WIDTH=100% BORDER=0 BGCOLOR="#6699CC">
<TR><TD COLSPAN=3><IMG SRC="../../../images/blank.gif" tppabs="http://www.sql.ru/images/blank.gif" height=3 width=1 alt=""></TD></TR>
<TR><TD VALIGN=TOP>&nbsp;<FONT FACE="Verdana,Arial" SIZE=5 COLOR=lightyellow>SQL.RU<BR><FONT SIZE=-5>&nbsp;client/server technologies</FONT></FONT><!--begin of Top100--><a href="javascript:if(confirm('http://top100.rambler.ru/top100/  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://top100.rambler.ru/top100/'" tppabs="http://top100.rambler.ru/top100/"><img src="../../../../counter.rambler.ru/top100.cnt-236431.gif" tppabs="http://counter.rambler.ru/top100.cnt?236431" alt="Rambler's Top100" width=1 height=1 border=0></a><!--end of Top100 code--></TD>
<TD WIDTH=468 HEIGHT=60 BGCOLOR=#6699CC ALIGN=RIGHT></TD>
<TD WIDTH=2><IMG SRC="../../../images/blank.gif" tppabs="http://www.sql.ru/images/blank.gif" height=1 width=2 alt=""></TD></TR>                                                      	
<TR HEIGHT=4><TD COLSPAN=3><IMG SRC="../../../images/blank.gif" tppabs="http://www.sql.ru/images/blank.gif" height=5 width=1 alt=""></TD></TR></TABLE>

</TD></TR>

<TR HEIGHT=15><TD bgcolor=#006699><FONT FACE="Verdana,Arial" SIZE=1 COLOR=WHITE><B><A CLASS="menu" 
HREF="javascript:if(confirm('http://www.sql.ru/  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.sql.ru/'" tppabs="http://www.sql.ru/">&nbsp;<FONT COLOR=white>Главная</FONT>&nbsp;</A>|<A CLASS="menu" 
HREF="javascript:if(confirm('http://www.sql.ru/docs  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.sql.ru/docs'" tppabs="http://www.sql.ru/docs">&nbsp;<FONT COLOR=yellow>Документация</FONT>&nbsp;</A>|<A CLASS="menu" 
HREF="javascript:if(confirm('http://www.sql.ru/articles  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.sql.ru/articles'" tppabs="http://www.sql.ru/articles">&nbsp;<FONT COLOR=white>Статьи</FONT>&nbsp;</A>|<A CLASS="menu" 
HREF="javascript:if(confirm('http://www.sql.ru/books  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.sql.ru/books'" tppabs="http://www.sql.ru/books">&nbsp;<FONT COLOR=white>Книги</FONT>&nbsp;</A>|<A CLASS="menu" 
HREF="javascript:if(confirm('http://www.sql.ru/forum/actualforum.aspx  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.sql.ru/forum/actualforum.aspx'" tppabs="http://www.sql.ru/forum/actualforum.aspx">&nbsp;<FONT COLOR=white>Форум</FONT>&nbsp;</A>|<A CLASS="menu" 
HREF="javascript:if(confirm('http://www.sql.ru/poll  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.sql.ru/poll'" tppabs="http://www.sql.ru/poll">&nbsp;<FONT COLOR=white>Опросы</FONT>&nbsp;</A>|<A CLASS="menu" 
HREF="javascript:if(confirm('http://www.sql.ru/forum/actualtopics.aspx?bid=11  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.sql.ru/forum/actualtopics.aspx?bid=11'" tppabs="http://www.sql.ru/forum/actualtopics.aspx?bid=11">&nbsp;<FONT COLOR=white>Гостевая</FONT>&nbsp;</A>|<A CLASS="menu"
HREF="javascript:if(confirm('http://www.sql.ru/subscribe  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.sql.ru/subscribe'" tppabs="http://www.sql.ru/subscribe">&nbsp;<FONT COLOR=white>Рассылка</FONT>&nbsp;</A>|<A CLASS="menu"
HREF="javascript:if(confirm('http://www.sql.ru/job  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.sql.ru/job'" tppabs="http://www.sql.ru/job">&nbsp;<FONT COLOR=white>Работа</FONT>&nbsp;</A>|<A CLASS="menu"
HREF="javascript:if(confirm('http://www.sql.ru/search  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.sql.ru/search'" tppabs="http://www.sql.ru/search">&nbsp;<FONT COLOR=white>Поиск</FONT>&nbsp;</A>|<A CLASS="menu"
HREF="javascript:if(confirm('http://www.sql.ru/faq  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.sql.ru/faq'" tppabs="http://www.sql.ru/faq">&nbsp;<FONT COLOR=white>FAQ</FONT>&nbsp;</A>|</B></FONT></TD></TR>
<TR><TD BGCOLOR=#F5F5F5>
</noindex>

<TABLE BORDER=0 CELLSPACING=10><TR><TD>
<CENTER>
<H2 class="headline">
19. ПОДДЕРЖКА ЦЕЛОСТНОСТИ ВАШИХ ДАННЫХ</H2></CENTER> 
Ранее в этой книге, мы указывали на определенные 
связи которые существуют между некоторыми полями типовых 
таблиц. Поле snum таблицы Заказчиков, например, соответствует полю 
snum в таблице Продавцов и таблице Порядков. Поле cnum таблицы 
Заказчиков также соответствует полю cnum таблицы Порядков. 
Мы назвали этот тип связи - справочной целостностью; и в ходе обсуждения, вы видели как ее можно использовать. 
<BR><BR> 
В этой главе, вы будете исследовать справочную целостность более под- 
робно и выясним все относительно ограничений которые вы можете использовать чтобы ее поддерживать. Вы также увидите, как предписывает- 
с это ограничение когда вы используете команды модификации DML. 
Поскольку справочна целостность включает в себя связь полей или групп 
полей, часто в разных таблицах, это действие может быть несколько слож- 
нее чем другие ограничения. 
По этой причине, хорошо иметь с ней полное знакомство, даже если вы 
не планируете создавать таблицы. Ваши команды модификации могут стать 
эффективнее с помощью ограничения справочной целостности ( как и с 
помощью других ограничений, но ограничение справочной целостности 
может воздействовать на другие таблицы кроме тех в которых оно определено), а определенные функции запроса, такие как объединения, являются 
многократно структурированы в терминах связей справочной целостности 
( как подчеркивалось в <A href="ch8.shtml.htm" tppabs="http://www.sql.ru/docs/sql/u_sql/ch8.shtml">Главе 8</A> ). 
 <A name=19.1>
<H3>ВНЕШНИЙ КЛЮЧ И РОДИТЕЛЬСКИЙ КЛЮЧ</H3>Когда все значения в одном поле таблицы представлены в поле другой 
таблицы, мы говорим что первое поле ссылается на второе. 
Это указывает на прямую связь между значениями двух полей. Например, 
каждый из заказчиков в таблице Заказчиков имеет поле snum которое ука- 
зывает на продавца назначенного в таблице Продавцов. 
Для каждого порядка в таблице Порядков, имеется один и только этот про- 
давец и один и только этот заказчик. Это отображается с помощью полей 
snum и cnum в таблице Порядков. 
<BR><BR> 
Когда одно поле в таблице ссылается на другое, оно называется - внешним 
ключом;  а поле на которое оно ссылается, называется - родительским ключом. 
Так что поле snum таблицы Заказчиков - это внешний ключ, а поле snum на 
которое оно ссылается в таблице Продавцов - это родительский ключ. 
<BR><BR> 
Аналогично, пол cnum и snum таблицы Порядков - это внешние ключи 
которые ссылаются к их родительским ключам с именами в таблице За- 
казчиков и таблице Продавцов. Имена внешнего ключа и родительского 
ключа не обязательно должны быть одинаковыми, это - только соглашение 
которому мы следуем чтобы делать соединение более понятным. 
 <A name=19.2>
<H3>МНОГО-СТОЛБЦОВЫЕ ВНЕШНИЕ КЛЮЧИ</H3>В действительности, внешний ключ не обязательно состоит только из одного 
пол. Подобно первичному ключу, внешний ключ может иметь любое число 
полей, которые все обрабатываются как единый модуль. Внешний ключ и 
родительский ключ на который он ссылается, конечно же, должны иметь 
одинаковый номер и тип пол, и находиться в одинаковом порядке. Внешние 
ключи состоящие из одного пол - те что мы использовали исключительно в 
наших типовых таблицах, наиболее общие. 
Чтобы сохранить простоту нашего обсуждения, мы будем часто говорить о 
внешнем ключе как об одиночном столбце. Это не случайно. Если это не от- 
метить, любой скажет о поле которое является внешним ключом, что оно 
также относится и к группе полей которая является внешним ключом. 
 <A name=19.3>
<H3>СМЫСЛ ВНЕШНЕГО И РОДИТЕЛЬСКОГО КЛЮЧЕЙ</H3>Когда поле - является внешним ключом, оно определенным образом связано 
с таблицей на которую он ссылается. Вы, фактически, говорите - " каждое 
значение в этом поле ( внешнем ключе ) непосредственно привязано к зна- 
чению в другом поле ( родительском ключе  )."  Каждое значение ( каждая 
строка ) внешнего ключа должно недвусмысленно ссылаться к одному и 
только этому значению (строке) родительского ключа. 
Если это так, то фактически ваша система, как говорится, будет в состоянии 
справочной целостности. 
  Вы можете увидеть это на примере. Внешний ключ snum в таблице Заказ- 
чиков имеет значение 1001 для строк Hoffman и Clemens. 
Предположим что мы имели две строки в таблице Продавцов со значением 
в поле snum = 1001. 
Как мы узнаем, к которому из двух продавцов были назначены заказчики 
Hoffman и Clemens ?  Аналогично, если нет никаких таких строк в таблице 
Продавцов, мы получим Hoffman и Clemens назначенными к продавцу 
которого не существует! 
<BR><BR> 
 
Понятно, что каждое значение во внешнем ключе должно быть представ- 
лено один, и только один раз, в родительском ключе. 
<BR><BR> 
Фактически, данное значение внешнего ключа может ссылаться только 
к одному значению родительского ключа не предполагая обратной возможности: т.е. любое число внешних ключей может ссылать к единственному 
значению родительского ключа. Вы можете увидеть это в типовых таблицах 
наших примеров. И Hoffman и Clemens назначены к Peel, так что оба их 
значения внешнего ключа совпадают с одним и тем же родительским ключом, что очень хорошо. Значение внешнего ключа должно ссылаться только 
к одному значению родительского ключа, зато значение родительского ключа может ссылаться с помощью любого количества значений внешнего 
ключа. 
В качестве иллюстрации, значения внешнего ключа из таблицы Заказчиков, 
совпавшие с их родительским ключом в Продавцов таблице,  показываются 
в Рисунке 19.1.  Для удобства мы не учитывали пол не относящиеся к этому 
примеру. 
 <A name=19.4>
<H3>ОГРАНИЧЕНИЕ FOREIGN KEY</H3>SQL поддерживает справочную целостность с ограничением FOREIGN KEY. 
Хотя ограничение FOREIGN KEY - это нова особенность в SQL, оно еще 
не обеспечивает его универсальности. Кроме того, некоторые его реализации, 
более сложны чем другие. Эта функция должна ограничивать значения которые вы можете ввести в вашу базу данных чтобы заставить внешний ключ и родительский ключ 
соответствовать принципу справочной целостности. 
Одно из действий ограничения Внешнего Ключа -  это отбрасывание значений 
для полей ограниченных как внешний ключ который еще не представлен в ро- 
дительском ключе. Это ограничение также воздействует на вашу способность 
изменять или удалять значения родительского ключа ( мы будем обсуждать 
это позже в этой главе ). 
 <A name=19.5>
<H3>КАК МОЖНО ПОЛЯ ПРЕДСТАВИТЬ В КАЧЕСТВЕ ВНЕШНИХ КЛЮЧЕЙ</H3>Вы используете ограничение FOREIGN KEY в команде CREATE TABLE 
( или ALTER TABLE ), которая содержит поле которое вы хотите объявить 
внешним ключом. Вы даете им родительскому ключу на которое вы будете 
ссылаться внутри ограничения FOREIGN KEY. Помещение этого ограничения в команду - такое же что в для других ограничений обсужденных в 
<A href="ch20.shtml.htm" tppabs="http://www.sql.ru/docs/sql/u_sql/ch20.shtml">предыдущей главе</A>. 
 
 
 
 
 
 
 
 
Рисунок 19.1:  Внешний Ключ таблицы Заказчиков с родительским ключом 
<BR><BR> 
Подобно большинству ограничений, оно может быть ограничением таблицы 
или столбца, в форме таблицы позволяющей использовать многочисленные 
пол как один внешний ключ. 
 <A name=19.6>
<H3>ВНЕШНИЙ КЛЮЧ КАК ОГРАНИЧЕНИЕ ТАБЛИЦЫ</H3> 
Синтаксис ограничения таблицы FOREIGN KEY: 
<PRE> 
   FOREIGN KEY &lt;COLUMN list> REFERENCES 
             &lt;PKTABLE> [ &lt;COLUMN list> ] 
</PRE> 
Первый список столбцов - это список из одного или более столбцов таблицы, 
которые отделены запятыми и будут созданы или изменены этой командой. 
Pktable - это таблица содержащая родительский ключ. Она может быть таблицей, которая создается или изменяется текущей командой. Второй список 
столбцов - это список столбцов которые будут составлять родительский ключ. 
Списки двух столбцов должны быть совместимы, т.е.: 
<BR><BR> 
* Они должны иметь одинаковое число столбцов. 
<BR><BR> 
* В данной последовательности, первый, второй, третий, и т.д., 
  столбцы списка столбцов внешнего ключа, должны иметь одинаковые 
  типы данных и размеры, что и первый, второй, третий, и т.д., столбцы 
  списка столбцов родительского ключа. 
  Столбцы в списках обоих столбцов не должны иметь одинаковых имен, 
  хотя мы и использовали такой способ в наших примерах чтобы делать 
  связь более понятной. 
<BR><BR> 
Создадим таблицу Заказчиков с полем snum определенным в качестве 
внешнего ключа ссылающегося на таблицу Продавцов: 
<PRE> 
 
            CREATE TABLE Customers 
            ( cnum   integer NOT NULL PRIMARY KEY 
              cname  char(10), 
              city   char(10), 
              snum   integer, 
              FOREIGN KEY (snum) REFERENCES Salespeople 
              ( snum ); 
</PRE> 
 
Имейте в виду, что при использовании ALTER TABLE вместо CREATE TABLE, 
для применения ограничения FOREIGN KEY, значения которые Вы указываете 
во внешнем ключе и родительском ключе, должны быть в состоянии справочной целостности. Иначе команда будет отклонена. Хотя  ALTER TABLE очень 
полезна из-за ее удобства, вы должны будете в вашей системе, по возможности каждый раз, сначала формировать структурные принципы, типа справочной целостности. 
 <A name=19.7>
<H3>ВНЕШНИЙ КЛЮЧ КАК ОГРАНИЧЕНИЕ СТОЛБЦОВ</H3>Вариант ограничения столбца ограничением FOREIGN KEY - по другому называется - ссылочное ограничение (REFERENCES), так как он фактически не со- 
держит в себе слов FOREIGN KEY, а просто использует слово REFERENCES, 
и далее им родительского ключа, подобно этому: 
<PRE> 
 
         CREATE TABLE Customers 
          ( cnum   integer NOT NULL PRIMARY KEY, 
            cname  char(10), 
            city   char(10), 
            snum   integer REFERENCES Salespeople (snum)); 
</PRE> 
Вышеупомянутое определяет Customers.snum как внешний ключ у которого 
родительский ключ - это Salespeople.snum. Это эквивалентно такому ограничению таблицы: 
 
    FOREIGN KEY (snum) REGERENCES Salespeople (snum) 
 <A name=19.8>
<H3>НЕ УКАЗЫВАТЬ СПИСОК СТОЛБЦОВ ПЕРВИЧНЫХ КЛЮЧЕЙM</H3>Используя ограничение FOREIGN KEY таблицы или столбца, вы можете 
не указывать список столбцов родительского ключа если родительский ключ 
имеет ограничение PRIMARY KEY. Естественно,  в случае ключей со многими 
полями, порядок столбцов во внешних и первичных ключах должен совпадать, 
и, в любом случае, принцип совместимости между двум ключами все еще 
применим. Например, если мы поместили ограничение PRIMARY KEY в поле 
snum таблицы Продавцов, мы могли бы использовать его как внешний 
ключ в таблице Заказчиков (подобно предыдущему примеру) в этой команде: 
<PRE> 
         CREATE TABLE Customers 
          ( cnum   integer NOT NULL PRIMARY KEY, 
            cname  char(10), 
            city   char(10), 
            snum   integer REFERENCES Salespeople); 
</PRE> 
Это средство встраивалось в язык, чтобы поощрять вас использовать первич- 
ные ключи в качестве родительских ключей. 
 <A name=19.9>
<H3>КАК СПРАВОЧНАЯ ЦЕЛОСТНОСТЬ ОГРАНИЧИВАЕТ ЗНАЧЕНИЯ РОДИТЕЛЬСКОГО КЛЮЧА</H3> 
Поддержание справочной целостности требует некоторых ограничений на 
значения, которые могут быть представлены в полях, объявленных как внешний ключ и родительский ключ. Родительский ключ должен быть структурен, 
чтобы гарантировать, что каждое значение внешнего ключа будет соответствовать одной указанной строке. Это означает, что он (ключ) должен быть 
уникальным и не содержать никаких пустых значений(NULL). Этого не достаточно для родительского ключа в случае выполнения такого требования как 
при объявлении внешнего ключа. SQL должен быть уверен что двойные значения или пустые значения (NULL) не были введены в родительский ключ. 
Следовательно вы должны убедиться, что все пол, которые используются как 
родительские ключи, имеют или ограничение PRIMARY KEY или ограничение UNIQUE, наподобие ограничения NOT NULL. 
 <A name=19.10>
<H3>ПЕРВИЧНЫЙ КЛЮЧ КАК УНИКАЛЬНЫЙ ВНЕШНИЙ КЛЮЧ</H3> 
Ссылка ваших внешних ключей только на первичные ключи, как мы это делали 
в типовых таблицах, -  хороша стратеги. Когда вы используете внешние клю- 
чи, вы связываете их не просто с родительскими ключами на которые они ссылаются; вы связываете их с определенной строкой таблицы где этот родительс- 
кий ключ будет найден. Сам по себе родительский ключ не обеспечивает ника- 
кой информации которая бы не была уже представлена во внешнем ключе. 
Смысл, например, пол snum как внешнего ключа в таблице Заказчиков - это 
связь которую он обеспечивает, не к значению пол snum на которое он ссылается, а к другой информации в таблице Продавцов, такой например как, 
имена продавцов, их местоположение, и так далее. 
Внешний ключ - это не просто связь между двум идентичными значениями; 
это - связь, с помощью этих двух значений, между двум строками таблицы 
указанной в запросе. 
  Это поле snum может использоваться чтобы связывать любую информацию 
в строке из таблицы Заказчиков со ссылочной строкой из таблицы Продавцов - 
например чтобы узнать - живут ли они в том же самом городе, кто имеет более длинное имя, имеет ли продавец кроме данного заказчика каких-то других 
заказчиков, и так далее. 
  Так как цель первичного ключа состоит в том, чтобы идентифицировать уникальность строки, это более логичный и менее неоднозначный выбор для внешнего ключа. Для любого внешнего ключа который использует уникальный ключ 
как родительский ключ, вы должны создать внешний ключ который бы использовал первичный ключ той же самой таблицы для того же самого действия. 
Внешний ключ который не имеет никакой другой цели кроме связывания строк, 
напоминает первичный ключ используемый исключительно для идентификации 
строк, и является хорошим средством сохранить структуру вашей базы данных 
ясной и простой, и - следовательно создающей меньше трудностей. 
 
 <A name=19.11>
<H3>ОГРАНИЧЕНИЯ ВНЕШНЕГО КЛЮЧА</H3> Внешний ключ, в частности, может содержать только те значения которые 
фактически представлены в родительском ключе или пустые(NULL). Попытка 
ввести другие значения в этот ключ будет отклонена. 
  Вы можете объявить внешний ключ как NOT NULL, но это необязательно, и 
в большинстве случаев, нежелательно. Например, предположим, что вы вводи- 
те заказчика не зная заранее, к какому продавцу он будет назначен. Лучший 
выход в этой ситуации, будет если использовать значение NOT NULL, которое 
должно быть изменено позже на конкретное значение. 
 <A name=19.12>
<H3>ЧТО СЛУЧИТСЯ, ЕСЛИ ВЫ ВЫПОЛНИТЕ КОМАНДУ МОДИФИКАЦИИ</H3> 
Давайте условимся, что все внешние ключи созданные в наших таблицах приме- 
ров, объявлены и предписаны с ограничениями внешнего ключа, следующим 
образом : 
<PRE> 
       CREATE TABLE Salespeople 
         (snum  integer NOT NULL PRIMARY KEY, 
          sname char(10) NOT NULL, 
          city  char(10), 
          comm  decimal); 
 
       CREATE TABLE Customers 
         (cnum   integer NOT NULL PRIMARY KEY, 
          cname  char(10) NOT NULL, 
          city   char(10), 
          rating integer, 
          snum   integer, 
          FOREIGN KEY (snum) REFERENCES Salespeople, 
          UNIQUE (cnum, snum) ; 
 
      CREATE TABLE Orders 
        (cnum  integer NOT NULL PRIMARY KEY, 
         amt   decimal, 
         odate date NOT NULL, 
         cnum  integer NOT NULL 
         snum  integer NOT NULL 
         FOREIGN KEY (cnum, snum) REFERENCES 
         CUSTOMERS (cnum, snum); 
</PRE> <A name=19.13>
<H3>ВКЛЮЧЕНИЕ ОПИСАНИЙ ТАБЛИЦЫ</H3>Имеется несколько атрибутов таких определений о которых нужно поговорить. 
Причина по которой мы решили сделать пол cnum и snum в таблице Порядков, единым внешним ключом - это гарантия того, что для каждого заказчика 
содержащегося в порядках, продавец кредитующий этот порядок - тот же что 
и указанный в таблице Заказчиков. Чтобы создать такой внешний ключ, мы бы- 
ли бы должны поместить ограничение таблицы UNIQUE в два пол таблицы 
Заказчиков, даже если оно необязательно для самой этой таблицы. Пока поле 
cnum в этой таблица имеет ограничение PRIMARY KEY, оно будет уникально 
в любом случае, и следовательно невозможно получить еще одну комбинацию 
пол cnum с каким-то другим полем. 
  Создание внешнего ключа таким способом поддерживает целостность базы 
данных, даже если при этом вам будет запрещено внутреннее прерывание по 
ошибке и кредитовать любого продавца, иного чем тот который назначен 
именно этому заказчику. 
<BR><BR> 
С точки зрения поддержания целостности базы данных, внутренние прерывания ( или исключения) конечно же нежелательны. Если вы их допускаете и 
в то же врем хотите поддерживать целостность вашей базы данных, вы можете объявить пол snum и cnum в таблице Порядков независимыми внешними ключами этих полей в таблице Продавцов и таблице Заказчиков, соответственно. 
Фактически, использование пол snum в таблице Порядков, как мы это делали, 
необязательно, хотя это полезно было сделать для разнообразия. Поле cnum 
связывая каждый порядок заказчиков в таблице Заказчиков, в таблице Порядков 
и в таблице Заказчиков, должно всегда быть общим чтобы находить правильное 
поле snum для данного порядка ( не разрешая никаких исключений ). 
Это означает что мы записываем фрагмент информации - какой заказчик назначен к какому продавцу - дважды, и нужно будет выполнять дополнительную 
работу чтобы удостовериться, что обе версии согласуются. 
Если мы не имеем ограничения внешнего ключа как сказано выше, эта ситуация будет особенно проблематична, потому что каждый порядок нужно будет 
проверять вручную ( вместе с запросом ), чтобы удостовериться что именно 
соответствующий продавец кредитовал каждую соответствующую продажу. 
Наличие такого типа информационной избыточности в вашей базе данных, называется деморализация ( denormalization ), что нежелательно в идеальной 
реляционной базе данных, хотя практически и может быть разрешена. 
Деморализация может заставить некоторые запросы выполняться быстрее, 
поскольку запрос в одной таблице выполняется всегда значительно быстрее 
чем в объединении. 
 <A name=19.14>
<H3>ДЕЙСТВИЕ ОГРАНИЧЕНИЙ</H3>Как такие ограничения воздействуют на возможность и  невозможность 
Вами использовать команды модификации DML?  Для полей, определен- 
ных как внешние ключи, ответ довольно простой: любые значения которые вы 
помещаете в эти пол с командой INSERT или UPDATE должны уже быть 
представлены в их родительских ключах. Вы можете помещать пустые(NULL) 
значения  в эти пол, несмотря на то что значения NULL не позволительны в 
родительских ключах, если они имеют ограничение NOT NULL. Вы можете 
удалять (DELETE ) любые строки с внешними ключами не используя роди- 
тельские ключи вообще. 
<BR><BR> 
Поскольку затронут вопрос об изменении значений родительского ключа, 
ответ, по определению ANSI, еще проще, но возможно несколько более 
ограничен: любое значение родительского ключа ссылаемого с помощью 
значения внешнего ключа, не может быть удалено или изменено. 
Это означает, например, что вы не можете удалить заказчика из таблицы 
Заказчиков пока он еще имеет порядки в таблице Порядков. 
В зависимости от того, как вы используете эти таблицы, это может быть 
или желательно или хлопотно. Однако - это конечно лучше чем иметь сис- 
тему, которая позволит вам удалить заказчика с текущими порядками и оставить таблицу Порядков ссылающейся на несуществующих заказчиков. 
Смысл этой системы ограничения в том, что создатель таблицы Порядков, 
используя таблицу Заказчиков и таблицу Продавцов как родительские клю- 
чи может наложить значительные ограничения на действия в этих таблицах. 
По этой причине, вы не сможете использовать таблицу которой вы не распоряжаетесь ( т.е. не вы ее создавали и не вы являетесь ее владельцем), по- 
ка владелец(создатель) этой таблицы специально не передаст вам на это 
право ( что объясняется в <A href="ch22.shtml.htm" tppabs="http://www.sql.ru/docs/sql/u_sql/ch22.shtml">Главе 22</A>). 
    Имеются некоторые другие возможные действия изменения родительс- 
кого ключа, которые не являются частью ANSI, но могут быть найдены в 
некоторых коммерческих программах. Если вы хотите изменить или удалить 
текущее ссылочное значение родительского ключа, имеется по существу 
три возможности: 
<BR> <BR> 
<li> Вы можете ограничить, или запретить, изменение ( способом ANSI ), обозначив, что изменения в родительском ключе - ограничены. 
 
<li> Вы можете сделать изменение в родительском ключе и тем самым сделать изменения во внешнем ключе автоматическим, что называется -      каскадным изменением. 
 
<li> Вы можете сделать изменение в родительском ключе, и установить внешний ключ в NULL, автоматически ( полагая, что NULLS разрешен во      внешнем ключе ), что называется - пустым изменением внешнего ключа. 
<BR> <BR> 
 
Даже в пределах этих трех категорий, вы можете не захотеть обрабатывать все 
команды модификации таким способом. INSERT, конечно, к делу не относится. 
Он помещает новые значения родительского ключа в таблицу, так что ни одно 
из этих значений не может быть вызвано в данный момент. Однако, вы можете 
захотеть позволить модификациям быть каскадными, но без удалений, и наоборот. 
Лучшей может быть ситуация которая позволит вам определять любую из трех 
категорий, независимо от команд UPDATE и DELETE. Мы будем следовательно ссылаться на эффект модификации (update effects) и эффект удаления 
( delete effects ), которые определяют, что случится если вы выполните коман- 
ды UPDATE или DELETE в родительском ключе. 
Эти эффекты, о которых мы говорили, называются: 
Ограниченные (RESTRICTED) изменения, 
Каскадируемые (CASCADES) изменения, и 
Пустые (NULL) изменения. 
  Фактические возможности вашей системы должны быть в строгом  стандар- 
те ANSI - это эффекты модификации и удаления, оба, автоматически ограниченные - для более идеальной ситуации описанной выше. В качестве иллюстрации, мы покажем несколько примеров того, что вы можете делать с полным 
набором эффектов модификации и удаления. Конечно, эффекты модификации 
и удаления, являющиеся нестандартными средствами, испытывают недостаток 
в стандартном госинтаксисе. Синтаксис который мы используем здесь, прост в 
написании и будет служить в дальнейшем для иллюстрации функций этих 
эффектов. 
<BR><BR> 
Для полноты эксперимента, позволим себе предположить что вы имеете причи- 
ну изменить поле snum  таблицы Продавцов в случае, когда наша таблица 
Продавцов изменяет разделы. ( Обычно изменение первичных ключей это не то 
что мы рекомендуем делать практически. Просто это еще один из доводов для 
имеющихся первичных ключей которые не умеют делать ничего другого кроме 
как, действовать как первичные ключи: они не должны изменяться. ) Когда вы 
изменяете номер продавца, вы хотите чтобы были сохранены все его заказчики. 
Однако, если этот продавец покидает свою фирму или компанию, вы можете не 
захотеть удалить его заказчиков, при удалении его самого из базы данных. 
Взамен, вы захотите убедиться, что заказчики назначены кому-нибудь еще. 
Чтобы сделать это вы должны указать UPDATE с Каскадируемым эффектом , 
и DELETE с Ограниченным эффектом. 
<PRE> 
          CREATE TABLE Customers 
            (cnum   integer NOT NULL PRIMARY KEY, 
             cname  char(10) NOT NULL, 
             city   char(10), 
             rating integer, 
             snum   integer REFERENCES Salespeople, 
             UPDATE OF Salespeople CASCADES, 
             DELETE OF Salespeople RESTRICTED); 
</PRE> 
Если вы теперь попробуете удалить Peel из таблицы Продавцов, команда 
будет не допустима, пока вы не измените значение пол snum заказчиков 
Hoffman и Clemens для другого назначенного продавца. 
С другой стороны, вы можете изменить значение пол snum для Peel на 
1009,  и Hoffman и Clemens будут также автоматически изменены. 
<BR><BR> 
  Третий эффект - Пустые (NULL) изменения. Бывает, что когда продавцы 
оставляют компанию, их текущие порядки не передаются другому продавцу. 
С другой стороны, вы хотите отменить все порядки автоматически для заказ- 
чиков, чьи счета вы удалите. Изменив номера продавца или заказчика можно 
просто передать их ему. Пример ниже показывает, как вы можете создать 
таблицу Порядков с использованием этих эффектов. 
<PRE> 
        CREATE TABLE Orders 
           (onum   integer NOT NULL PRIMARY KEY, 
            amt    decimal, 
            odate  date NOT NULL 
            cnum   integer NOT NULL REFERENCES Customers 
            snum   integer REFERENCES Salespeople, 
            UPDATE OF Customers CASCADES, 
            DELETE OF Customers CASCADES, 
            UPDATE OF Salespeople CASCADES, 
            DELETE OF Salespeople NULLS); 
</PRE> 
Конечно, в команде DELETE с эффектом Пустого изменения в таблице 
Продавцов, ограничение NOT NULL должно быть удалено из пол snum. 
 <A name=19.15>
<H3>ВНЕШНИЕ КЛЮЧИ КОТОРЫЕ ССЫЛАЮТСЯ ОБРАТНО К ИХ ПОДЧИНЕННЫМ ТАБЛИЦАМ</H3>Как было упомянуто ранее, ограничение FOREIGN KEY  может представить 
им этой частной таблице, как таблицы родительского ключа. Далеко не бу- 
дучи простой, эта особенность может пригодиться. Предположим, что мы 
имеем таблицу Employees с полем manager(администратор). Это поле содер- 
жит номера каждого из служащих, некоторые из которых являются еще и ад- 
министраторами. 
Но так как каждый администратор - в то же врем остается служащим, то 
он естественно будут также представлен в этой таблице. Давайте создадим 
таблицу, где номер служащего ( столбец с именем empno ), объявляется как 
первичный ключ, а администратор, как внешний ключ, будет ссылаться 
на нее: 
<PRE> 
     CREATE TABLE Employees 
        (empno   integer NOT NULL PRIMARY KEY, 
         name    char(10) NOT NULL UNIOUE, 
         manager integer REFERENCES Employees); 
</PRE> 
( Так как внешний ключ это ссылаемый первичный ключ таблицы, список 
столбцов может быть исключен. )  Имеется содержание этой таблицы: 
<PRE> 
 
          EMPNO          NAME           MANAGER 
          _____         ________        _______ 
 
          1003          Terrence         2007 
 
          2007          Atali            NULL 
 
          1688          McKenna          1003 
 
          2002          Collier          2007 
 
</PRE> 
Как вы можете видеть, каждый из них( но не Atali ) , ссылается на другого 
служащего в таблице как на своего администратора. Atali, имеющий наивысший номер в таблице, должен иметь значение установленное в NULL. 
Это дает другой принцип справочной целостности. Внешний ключ, который 
ссылается обратно к частной таблице, должен позволять значения = NULL. 
Если это не так, как бы вы могли вставить первую строку ? 
Даже если эта первая строка ссылается к себе самой, значение родительского 
ключа должно уже быть установлено, когда вводится значение внешнего клю- 
ча.  Этот принцип будет верен, даже если внешний ключ ссылается обратно к 
частной таблице не напрямую а с помощью ссылки к другой таблице, которая 
затем ссылается обратно к таблице внешнего ключа. Например, предположим, 
что наша таблица Продавцов имеет дополнительное поле которое ссылается на 
таблицу Заказчиков, так, что каждая таблица ссылается на другую, как показано 
в следующем операторе CREATE TABLE: 
<PRE> 
         CREATE TABLE Salespeople 
           (snum  integer NOT NULL PRIMARY KEY, 
            sname char(10) NOT NULL, 
            city  char(10), 
            comm  declmal, 
            cnum  integer REFERENCES Customers); 
 
        CREATE TABLE Customers 
          (cnum   integer NOT NULL PRIMARY KEY, 
           cname  char(10) NOT NULL, 
           city   char(10), 
           rating integer, 
           snum   integer REFERENCES Salespeople); 
</PRE> 
 Это называется - перекрестной ссылкой. 
 SQL поддерживает это теоретически, но практически это может составить 
проблему. Люба таблица из этих двух, созданная первой является ссылоч- 
ной таблицей которая еще не существует для другой. В интересах обеспечения перекрестной ссылки, SQL фактически позволяет это, но никакая таблица не будет пригодна для использования пока они обе находятся в процессе 
создания. С другой стороны, если эти две таблицы создаются различными 
пользователями, проблема становится еще более трудной. 
Перекрестна ссылка может стать полезным инструментом, но она не без 
неоднозначности и опасностей. Предшествующий пример, например, не сов- 
сем пригоден для использования: потому что он ограничивает продавца оди- 
ночным заказчиком, и кроме того совсем необязательно использовать перекрестную ссылку чтобы достичь этого. Мы рекомендуем чтобы вы были осторожны в его использовании и анализировали, как ваши программы управ- 
лют эффектами модификации и удаления а также процессами привилегий 
и диалоговой обработки запросов перед тем как вы создаете перекрестную 
систему справочной целостности. 
( Привилегии и диалоговая обработка запросов будут обсуждаться, соответственно, в<A href="ch22.shtml.htm" tppabs="http://www.sql.ru/docs/sql/u_sql/ch22.shtml"> Главах 22</A> И<A href="ch23.shtml.htm" tppabs="http://www.sql.ru/docs/sql/u_sql/ch23.shtml"> 23</A>.) 
<A name=19.16>
<H3>РЕЗЮМЕ</H3>Теперь вы имеете достаточно хороше управление справочной целостностью. 
Основная идея в том, что все значения внешнего ключа ссылаются к указан- 
ной строке родительского ключа. Это означает, что каждое значение внешне- 
го ключа должно быть представлено один раз, и только один раз, в родитель- 
ском ключе. Всякий раз, когда значение помещается во внешний ключ, роди- 
тельский ключ проверяется, чтобы удостовериться, что его значение представлено; иначе, команда будет отклонена. Родительский ключ должен иметь 
Первичный Ключ (PRIMARY KEY) или  Уникальное (UNIQUE) ограничение, гарантирующее, что значение не будет представлено более чем один раз. 
Попытка изменить значение родительского ключа, которое в настоящее врем 
представлено во внешнем ключе, будет вообще отклонена. 
Ваша система может, однако, предложить вам выбор, чтобы получить значение 
внешнего ключа установленного в NULL или для получения нового значения ро- 
дителького ключа, и указания какой из них может быть получен независимо 
для команд UPDATE и DELETE. 
Этим завершается наше обсуждение команды CREATE TABLE. 
Далее мы представим вас другому типу команды - CREATE. В <A href="ch20.shtml.htm" tppabs="http://www.sql.ru/docs/sql/u_sql/ch20.shtml">Главе 20</A>, 
вы обучитесь представлению объектов данных которые выглядят и действуют 
подобно таблице, но в действительности являются результатами запросов. 
Некоторые функции ограничений могут также выполняться представлениями, 
так что вы сможете лучше оценить вашу потребность к ограничениям, после 
того, как вы прочитаете следующие три главы. 
 <A name=19.17>
<H3>РАБОТА С SQL</H3>1. Создайте таблицу с именем Cityorders. Она должна содержать такие же 
   пол  onum, amt, и snum что и таблица Порядков, и такие же пол 
   cnum и city что и таблица Заказчиков, так что порядок каждого 
   заказчика будет вводиться в эту таблицу вместе с его городом. 
   Поле оnum будет первичным ключом Cityorders. Все пол в Cityorders 
   должны иметь ограничения при сравнении с таблицами Заказчиков и 
   Порядков. Допускается, что родительские ключи в этих таблицах уже 
   имеют соответствующие ограничения. 
<BR><BR> 
2. Усложним проблему. Переопределите таблицу Порядков следующим 
   образом:  добавьте новый столбец с именем prev, который будет 
   идентифицирован для каждого порядка, поле onum предыдущего 
   порядка для этого текущего заказчика. 
   Выполните это с использованием внешнего ключа ссылающегося на 
   саму таблицу Порядков. 
   Внешний ключ должен ссылаться также на поле cnum заказчика, 
   обеспечивающего определенную предписанную связь между текущим 
   порядком и ссылаемым. 
<BR><BR> 
( См.<A href="a.shtml.htm#19" tppabs="http://www.sql.ru/docs/sql/u_sql/a.shtml#19"> Приложение A </A>для ответов. ) 
 
</TD></TR></TABLE>
</TD></TR>
<TR BGCOLOR=#6699CC><TD><TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD BGCOLOR=#6699CC VALIGN=CENTER HEIGHT = 40><FONT SIZE=-10>
<!--begin of Top100 logo-->
<a href="javascript:if(confirm('http://top100.rambler.ru/top100/  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://top100.rambler.ru/top100/'" tppabs="http://top100.rambler.ru/top100/">
<img src="../../../../top100-images.rambler.ru/top100/banner-88x31-rambler-gray2.gif" tppabs="http://top100-images.rambler.ru/top100/banner-88x31-rambler-gray2.gif" alt="Rambler's Top100" width=88 height=31 border=0></a>
<!--end of Top100 logo -->
</FONT>
<!--Rating@Mail.ru COUNTER--><a target=_top
href="javascript:if(confirm('http://top.mail.ru/jump?from=58574  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://top.mail.ru/jump?from=58574'" tppabs="http://top.mail.ru/jump?from=58574"><img
src="../../../../top.list.ru/counter-id=58574;t=94.gif" tppabs="http://top.list.ru/counter?id=58574;t=94"
border=0 height=18 width=88
alt="Рейтинг@Mail.ru"></a><!--/COUNTER-->
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a style="font : bold 10px verdana; color : white" href="javascript:if(confirm('http://hosting.parking.ru/  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://hosting.parking.ru/'" tppabs="http://hosting.parking.ru/">Хостинг от компании Parking.ru</a>
<script src="../../../../www.google-analytics.com/urchin.js" tppabs="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-265508-1";
urchinTracker();
</script>
</TD>
<TD BGCOLOR=#6699CC ALIGN=right><FONT COLOR=white FACE="Tahoma,Arial" SIZE=1>&nbsp;Administrator:&nbsp;<A STYLE="color :white" HREF="mailto:admin@sql.ru">admin@sql.ru</A>&nbsp;<BR>Last update: <FONT COLOR=white>05 июн 2007&nbsp;</FONT></FONT></TD></TR></TABLE>
</TD></TR></TABLE></TD></TR></TABLE>

</BODY></HTML>

